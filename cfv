#! /usr/bin/env python

#    cfv - Command-line File Verify
#    Copyright (C) 2000  Matthew Mueller <donut@azstarnet.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import getopt, re, os, string, sys, errno, time #, glob
import imp

types={}
class CFVException(Exception):
	pass

class CFVValueError(CFVException):#invalid argument in user input
	pass

class CFVNameError(CFVException):#invalid command in user input
	pass

class CFVSyntaxError(CFVException):#error in user input
	pass

class CFVVerifyError(CFVException):#invalid crc/filesize/etc
	pass

class Stats:
	num=0
	ok=0
	badsize=0
	badcrc=0
	notfound=0
	ferror=0
	bytesread=0L #use long int for size, to avoid possible overflow.
	unverifiedfiles=[]
	unverified=0

class Config:
	verbose=0 # -1=quiet  0=norm  1=noisy
	docrcchecks=1
	dirsort=1
	cmdlinesort=1
	recursive=0
	showunverified=0
	defaulttype='sfv'
	ignorecase=0
	fixpaths=''
	showpaths=2
	def setdefault(self,type):
		if type in types.keys():
			self.defaulttype=type
		else:
			raise CFVValueError, "invalid default type '%s'"%type
	def setintr(self,o,v,min,max):
		try:
			x=int(v)
			if x>max or x<min:
				raise CFVValueError, "out of range int '%s' for %s"%(v,o)
			self.__dict__[o]=x
		except ValueError:
			raise CFVValueError, "invalid int type '%s' for %s"%(v,o)
	def setbool(self,o,v):
		v=string.lower(v)
		if v in ('yes','on','true','1'):
			x=1
		elif v in ('no','off','false','0'):
			x=0
		else:
			raise CFVValueError, "invalid bool type '%s' for %s"%(v,o)
		self.__dict__[o]=x
	def setstr(self,o,v):
		self.__dict__[o]=v
	def setx(self,o,v):
		if o=="default":
			self.setdefault(v)
		elif o in ("dirsort","cmdlinesort","verbose","showunverified","ignorecase"):
			self.setbool(o,v)
		elif o in ("recursive","showpaths"):
			self.setintr(o,v,0,2)
		elif o=="fixpaths":
			self.setstr(o,v)
		else:
			raise CFVNameError, "invalid option '%s'"%o
	def readconfig(self):
		filename=os.path.expanduser("~/.cfvrc")
		if os.path.isfile(filename):
			file=open(filename,"r")
			l=0
			while 1:
				l=l+1
				s=file.readline()
				if not len(s):
					break #end of file
				if s[0]=="#":
					continue #ignore lines starting with #
				s=re.sub('[\n\r]','',s)
				if not len(s):
					continue #ignore blank lines
				x=re.search("^(.*) (.*)$",s)
				if not x:
					raise CFVSyntaxError, "%s:%i: invalid line '%s'"%(filename,l,s)
				else:
					o,v=x.groups()
					try:
						self.setx(o,v)
					except CFVException, err:
						raise sys.exc_info()[0], "%s:%i: %s"%(filename,l,err), sys.exc_info()[2] #reuse the traceback of the original exception, but add file and line numbers to the error
	def __init__(self):
		self.readconfig()

version='1.6'


#---------- md5 ----------


try:
	import fchksum
	def getfilemd5(file):
		global stats
		c,s=fchksum.fmd5t(file)
		stats.bytesread=stats.bytesread+s
		return c
except ImportError:
	import md5
	def getfilemd5(file):
		global stats
		m=md5.new()
		f=open(file,'rb')
		while 1:
			x=f.read(65536)
			if not len(x):
				c=""
				for z in m.digest():
					c=c+'%02x'%ord(z)
				return c
			stats.bytesread=stats.bytesread+len(x)
			m.update(x)


def testfilemd5(filename,filecrc):
	c=getfilemd5(filename)
	if c!=string.lower(filecrc):
		return c

def testmd5(file,testfiles):
	rem=re.compile(r'([0-9a-fA-F]{32}) ([ *])(.+)$')
	while 1:
		l=file.readline()
		if not len(l):
			return
		x=rem.match(l)
		if x:
			if x.group(2)==' ':
				print 'warning: file %s tested in textmode' %x.group(3)
			testfile(testfiles,testfilemd5,x.group(3),x.group(1))


types['md5']=imp.new_module('cfvmd5')
types['md5'].checksumfile=testmd5
types['md5'].testmatch=(r'[0-9a-fA-F]{32} [ *].+',0)
types['md5'].automake_filenametest=lambda o: string.find(o,'md5')>=0
types['md5'].make_std_filename=lambda o: o+'.md5'
types['md5'].writeheader=lambda file: None
types['md5'].make_dofile=lambda a: '%s *%s\n'%(getfilemd5(a),a)


#---------- sfv ----------

try:
	import fchksum
	def getfilecrc(file):
		global stats
		c,s=fchksum.fcrc32t(file)
		stats.bytesread=stats.bytesread+s
		return c
except ImportError:
	import zlib
	def getfilecrc(file):
		global stats
		f=open(file,'rb')
		c=zlib.crc32('')
		while 1:
			x=f.read(65536)
			if not len(x):
				return "%08X"%c
			stats.bytesread=stats.bytesread+len(x)
			c=zlib.crc32(x,c)


#def testfilecrc32(filename,filecrc):
#	c=getfilecrc(filename)
#	if c<0: #the crc func returns a signed int...
#		c=2**32L + c
#	if c!=string.atol(filecrc,16):
#	#if '%X'%c != filecrc:
#		return "%X"%c
def testfilecrc32(filename,filecrc):
	c=getfilecrc(filename)
	#if c!=string.upper(filecrc):
	if string.atol(c,16)!=string.atol(filecrc,16):
		return c
		

def testsfv(file,testfiles):
	rem=re.compile(r'(.+) ([0-9a-fA-F]+)\s*$')
	while 1:
		l=file.readline()
		if not len(l):
			return
		if l[0]==';':
			continue
		x=rem.match(l)
		if x:
			testfile(testfiles,testfilecrc32,x.group(1),x.group(2))

types['sfv']=imp.new_module('cfvsfv')
types['sfv'].checksumfile=testsfv
types['sfv'].testmatch=(r';.*generated (by|using) (.* on|.*sfv|.*crc32)',re.IGNORECASE)
types['sfv'].automake_filenametest=lambda o: o[-3:]=='sfv'
types['sfv'].make_std_filename=lambda o: o+'.sfv'
types['sfv'].writeheader=lambda file: file.write('; Generated by cfv v%s on %s\n;\n'%(version,time.strftime('%Y-%m-%d at %H:%M.%S',time.gmtime(time.time()))))
#types['sfv'].make_dofile=lambda a: '%s %08X\n'%(a,getfilecrc(a))
types['sfv'].make_dofile=lambda a: '%s %s\n'%(a,getfilecrc(a))


#---------- csv ----------

def testcsv(file,testfiles):
	rem=re.compile(r'([^,]+),([0-9]+),([0-9a-fA-F]+),')
	while 1:
		l=file.readline()
		if not len(l):
			return
		x=rem.match(l)
		if x:
			testfile(testfiles,testfilecrc32,x.group(1),x.group(3),x.group(2))

types['csv']=imp.new_module('cfvcsv')
types['csv'].checksumfile=testcsv
types['csv'].testmatch=('[^,]+,[0-9]+,[0-9a-fA-F]+,[\n\r]*$',0)
types['csv'].automake_filenametest=lambda o: o[-3:]=='csv'
types['csv'].make_std_filename=lambda o: o+'.csv'
types['csv'].writeheader=lambda file: None
types['csv'].make_dofile=lambda a: '%s,%i,%s,\n'%(a,os.path.getsize(a),getfilecrc(a))


#---------- csv with 4 fields ----------

def testcsv4(file,testfiles):
	rem=re.compile(r'([^,]+),([0-9]+),([0-9a-fA-F]+),([^,]*),')
	while 1:
		l=file.readline()
		if not len(l):
			return
		x=rem.match(l)
		if x:
			testfile(testfiles,testfilecrc32,os.path.join(x.group(4),x.group(1)),x.group(3),x.group(2)) 

types['csv4']=imp.new_module('cfvcsv4')
types['csv4'].checksumfile=testcsv4
types['csv4'].testmatch=(r'[^,]+,[0-9]+,[0-9a-fA-F]+,[^,]*,',0)
types['csv4'].automake_filenametest=lambda o: 0
types['csv4'].make_std_filename=lambda o: o+'.csv'
types['csv4'].writeheader=lambda file: None
types['csv4'].make_dofile=lambda a: '%s,%i,%s,%s,\n'%(os.path.split(a)[1],os.path.getsize(a),getfilecrc(a),os.path.split(a)[0])


#---------- csv with only 2 fields ----------

def testcsv2(file,testfiles):
	rem=re.compile(r'([^,]+),([0-9]+),')
	while 1:
		l=file.readline()
		if not len(l):
			return
		x=rem.match(l)
		if x:
			testfile(testfiles,None,x.group(1),None,x.group(2))

types['csv2']=imp.new_module('cfvcsv2')
types['csv2'].checksumfile=testcsv2
types['csv2'].testmatch=('[^,]+,[0-9]+,[\n\r]*$',0)
types['csv2'].automake_filenametest=lambda o: 0
types['csv2'].make_std_filename=lambda o: o+'.csv'
types['csv2'].writeheader=lambda file: None
types['csv2'].make_dofile=lambda a: '%s,%i,\n'%(a,os.path.getsize(a))


#---------- generic ----------

def perhaps_showpath(file,dir=None):
	if config.showpaths==1 or (config.showpaths==2 and config.recursive):
		if dir==None:
			dir=os.getcwd()
		return os.path.join(dir,file)
	return file

def findfile_nocase(filename):
	head=filename
	parts=[]
	cur="."
	while 1:
		head,tail=os.path.split(head)
		if len(tail):
			parts.insert(0,string.lower(tail))
		else:
			if len(head):
				parts.insert(0,string.lower(head))
			break
	#print filename,parts
	for i in range(0,len(parts)):
		p=parts[i]
		matches=filter(lambda f,p=p: string.lower(f)==p,os.listdir(cur))
		if i==len(parts)-1:#if we are on the last part of the path, we want to match a file
			matches=filter(os.path.isfile,matches)
		else:#otherwise, we want to match a dir
			matches=filter(os.path.isdir,matches)
		if len(matches)==0:
			raise IOError, (errno.ENOENT,os.strerror(errno.ENOENT))
		if len(matches)>1:
			raise IOError, (errno.EEXIST,"More than one name matches %s"%os.path.join(cur,p))
		if cur=='.':
			cur=matches[0] #don't put the ./ on the front of the name
		else:
			cur=os.path.join(cur,matches[0])
	return cur
	
def fixpath(filename):
	return re.sub('['+re.escape(config.fixpaths)+']',os.sep,filename)

def normpath(filename):
	t=os.path.normpath(filename)
	if re.match(r"[a-z]:\\",t[0:3],re.I): #we can't use os.path.splitdrive, since we want to get rid of it even if we are not on a dos system.
		return t[3:]
	if t[0]==os.sep:
		return t[1:]
	return t

def testfile(testfiles,crctestfunc,filename,filecrc,filesize=-1):
	if len(config.fixpaths):
		filename=fixpath(filename)
	filename=normpath(filename)
	if testfiles:
		if config.ignorecase:
			if string.lower(filename) not in testfiles:
				return
		elif filename not in testfiles:
			return
	global stats,config
	stats.num=stats.num+1
	l_filename=filename
	try:
		if config.ignorecase:
			if not os.path.exists(l_filename):
				l_filename=findfile_nocase(l_filename)
		if config.showunverified:
			try:
				stats.unverifiedfiles[-1].remove(l_filename)
			except ValueError:
				pass #don't error if file has already been removed.
		if filesize>=0:
			fs=os.path.getsize(l_filename)
			if fs!=string.atoi(filesize):
				stats.badsize=stats.badsize+1
				raise CFVVerifyError, 'file size does not match (%s!=%i)'%(filesize,fs)
		if config.docrcchecks and filecrc!=None:
			c=crctestfunc(l_filename,filecrc)
			if c:
				stats.badcrc=stats.badcrc+1
				raise CFVVerifyError, 'crc does not match (%s!=%s)'%(filecrc,c)
		else:
			if not os.path.exists(l_filename):
				raise EnvironmentError, (errno.ENOENT,"missing")
			if not os.path.isfile(l_filename):
				raise EnvironmentError, (errno.ENOENT,"not a file")
			filecrc="exists" #since we didn't actually test the crc, make verbose mode merely say it exists
	except EnvironmentError, a:
		if a[0]==errno.ENOENT:
			stats.notfound=stats.notfound+1
		else:
			stats.ferror=stats.ferror+1
		if config.verbose>=0 or a[0]!=errno.ENOENT:
			print '%s : %s'%(perhaps_showpath(l_filename),a[1])
		return -1
	except CFVVerifyError, a:
		if config.verbose>=0:
			print '%s : %s'%(perhaps_showpath(l_filename),a)
		return -2
	stats.ok=stats.ok+1
	if config.verbose>0:
		if filesize>=0:
			print '%s : OK (%i,%s)'%(perhaps_showpath(filename),fs,filecrc)
		else:
			print '%s : OK (%s)'%(perhaps_showpath(filename),filecrc)

def test(filename,testfiles):
	file=open(filename,'r')
	l=file.readline(512)#limit max line length to be read for testing, in case its a binary file or something.
	file.seek(0)#go back to start so that type-specific test funcs get whole file
	for typename,type in types.items():
		if re.match(type.testmatch[0],l,type.testmatch[1]):
			if config.showunverified and filename in stats.unverifiedfiles[-1]:#we can't expect the checksum file itself to be checksummed
				stats.unverifiedfiles[-1].remove(filename)
			if config.verbose>0:
				print 'testing from %s (%s)'%(filename,typename)
			type.checksumfile(file,testfiles)
			return
	print "I don't recognize the type of %s"%filename

def make(type,ifilename,testfiles):
	global stats
	if ifilename:
		filename=ifilename
	else:
		filename=type.make_std_filename(os.path.basename(os.getcwd()))
	if os.path.exists(filename):
		print "%s already exists"%filename
		sys.exit(1)
	if not testfiles or not len(testfiles):
		tfauto=1
		#testfiles=glob.glob('*')
		testfiles=os.listdir('.')
		if config.dirsort:
			testfiles.sort()
	else:
		tfauto=0
	file=None
	testdirs=[]
	
	i=0
#	for f in testfiles:
	while i<len(testfiles):
		f=testfiles[i]
		i=i+1
		if not os.path.isfile(f):
			if config.recursive and os.path.isdir(f):
				if config.recursive==1:
					testdirs.append(f)
				elif config.recursive==2:
					rfiles=os.listdir(f)
					if config.dirsort:
						rfiles.sort()
					testfiles[i:i]=map(lambda x,p=f: os.path.join(p,x), rfiles)
				continue
			if tfauto:#if user isn't specifying files, don't even try to add dirs and stuff, and don't print errors about it.
				continue
		stats.num=stats.num+1
		if file==None:
			file=open(filename,'w')
			type.writeheader(file)
			dof=type.make_dofile
		try:
			s=dof(f)
		except EnvironmentError, a:
			if a[0]==errno.ENOENT:
				stats.notfound=stats.notfound+1
			else:
				stats.ferror=stats.ferror+1
			if config.verbose>=0 or a[0]!=errno.ENOENT:
				print '%s : %s'%(f,a[1])
			continue
		file.write(s)
		stats.ok=stats.ok+1
	if file!=None:
		file.close()
	
	for f in testdirs:
		olddir=os.getcwd()
		os.chdir(f)
		make(type,ifilename,None)
		os.chdir(olddir)

def start_test_dir():
	if not config.showunverified:
		return
	global stats;
	if len(args):
		filelist=args[:] #make a copy so we don't modify the args list (teehee)
	else:
		filelist=os.listdir('.')
	#dir=os.getcwd()
	#stats.unverifiedfiles[dir]=map(lambda d: os.path.join(dir,d),filelist))
	#stats.unverifiedfiles[dir]=filelist
	stats.unverifiedfiles.append(filelist)
def finish_test_dir():
	if not config.showunverified:
		return
	global stats;
	dir=os.getcwd()
	unverified=stats.unverifiedfiles.pop()
	for file in unverified:
		if os.path.isfile(file):
			print '%s : not verified'%perhaps_showpath(file,dir)
			stats.unverified=stats.unverified+1

stats=Stats()
config=Config()
manual=0
mode=0
type='auto'
starttime=time.time()

def printusage():
	print 'Usage: cfv [opts] [-T|-C] [-t type] [-f file] [files...]'
	print '  -r       recursive mode 1 (make seperate chksum files for each dir)'
	print '  -rr      recursive mode 2 (make a single file with deep listing in it)'
	print '  -R       not recursive (default)'
	print '  -T       test mode (default)'
	print '  -C       create mode'
	print '  -t <t>   set type to <t> (%sor auto(default))'%reduce(lambda a,b: a+b+', ',types.keys(),'')
	print '  -f <f>   use <f> as list file'
	print '  -m       check only for missing files (don\'t compare checksums)'
	print '  -M       check checksums (default)'
	print '  -i       ignore case'
	print '  -I       don\'t ignore case (default)'
	print '  -u       show unverified files'
	print '  -U       don\'t show unverified files (default)'
	print '  -v       verbose'
	print '  -V       not verbose (default)'
	print ' --fixpaths=<s>  replace any chars in <s> with %s'%os.sep
	print ' --showpaths=<p> show full paths 0:never, 1:always, 2:in recursive mode(default)'
	sys.exit()
def printhelp():
	print 'cfv v%s - Copyright (C) 2000 Matthew Mueller - GPL license'%version
	printusage()

try:
	optlist, args = getopt.getopt(sys.argv[1:], 'rRTCt:f:mMuUiIvVh?', ['fixpaths=','showpaths='])
except getopt.error, a:
	print "cfv: %s"%a
	printusage()

if config.cmdlinesort:
	args.sort()

prevopt=('','')
for o,a in optlist:
	if o=='-T':
		mode=0
	elif o=='-C':
		mode=1
	elif o=='-t':
		if not a in ['auto']+types.keys():
			print 'type %s not recognized'%a
			sys.exit(1)
		type=a
	elif o=='-f':
		manual=1 #filename selected manually, don't try to autodetect
		filename=a
		if mode==0:
			if config.ignorecase:
				args=map(string.lower,args) #lowercase it all now, so we don't have to keep doing it over and over in the testfile
			start_test_dir()
			if type=='auto':
				test(a,args)
			else:
				types[type].checksumfile(open(a,'r'),args)
			finish_test_dir()
		else:
			if type!='auto':
				make(types[type],a,args)
			else:
				ok=0
				for type in types.values():
					if type.automake_filenametest(a):
						make(type,a,args)
						ok=1
						break;
				if not ok:
					print 'specify a filetype with -t, or use standard extension'
					sys.exit(1)
	elif o=='-U':
		config.showunverified=0
	elif o=='-u':
		config.showunverified=1
	elif o=='-I':
		config.ignorecase=0
	elif o=='-i':
		config.ignorecase=1
	elif o=='-m':
		config.docrcchecks=0
	elif o=='-M':
		config.docrcchecks=1
	elif o=='-r':
		if prevopt=='-r':
			config.recursive=2
		else:
			config.recursive=1
	elif o=='-R':
		config.recursive=0
	elif o=='-v':
		config.verbose=1
	elif o=='-V':
		config.verbose=0
	elif o=='--showpaths':
		config.showpaths=int(a)
	elif o=='--fixpaths':
		config.fixpaths=a
	elif o=='-h' or o=='-?':
		printhelp()
	prevopt=o

if not manual:
	if mode==0:
		rem=re.compile(r'md5|\.(csv|sfv)$',re.IGNORECASE)#md5sum files have no standard extension, so just search for files with md5 in the name anywhere, and let the test func see if it really is one.
		if config.ignorecase:
			args=map(string.lower,args) #lowercase it all now, so we don't have to keep doing it over and over in the testfile
		def autotest(rem):
			start_test_dir()
			for a in os.listdir('.'):
				if config.recursive and os.path.isdir(a):
					olddir=os.getcwd()
					os.chdir(a)
					autotest(rem)
					os.chdir(olddir)
				if rem.search(a):
					test(a,args)
			finish_test_dir()
		autotest(rem)
	else:
		if type=='auto':
			type=config.defaulttype
		make(types[type],None,args)

sys.stdout.write('%i files'%stats.num)
sys.stdout.write(', %i OK' %stats.ok)
if stats.badcrc:
	sys.stdout.write(', %i badcrc' %stats.badcrc)
if stats.badsize:
	sys.stdout.write(', %i badsize' %stats.badsize)
if stats.notfound:
	sys.stdout.write(', %i not found' %stats.notfound)
if stats.ferror:
	sys.stdout.write(', %i file errors' %stats.ferror)
if stats.unverified:
	sys.stdout.write(', %i unverified' %stats.unverified)

elapsed=time.time()-starttime
sys.stdout.write('.  %.2f seconds, '%(elapsed))
if elapsed==0.0:
	sys.stdout.write('%.1fK'%(stats.bytesread/1024.0))
else:
	sys.stdout.write('%.1fK/s'%(stats.bytesread/elapsed/1024.0))

sys.stdout.write('\n')

if stats.badcrc or stats.badsize or stats.notfound or stats.ferror or stats.unverified:
	sys.exit(1)
